# 不使用运算符+和- 计算两整数ab的和
# 首先观察二进制加法的情况 0+0=00 0+1=01 1+0=01 1+1=10 因此如果两个加数不同 原位就是1 相同就是0 满足异或运算
# 接下来考虑进位 进位值存在如果两个加数都是1就进位 其余不进位的特点 因此进位值是与运算
# 那么答案就是 (a^b)+(a&b)<<1 那如何去掉这个+呢，只要不断循环到不出现进位就行了
# 题目默认中结果不为负数 因此会用mask来去除掉溢出的负号

# 负数高位会无限补1 -2 存储为：11111111111…10
# 正数高位会无限补0 1  存储为：00000000000…01
# 因此算进位的时候 进位是0
# 然后算原位 原位是11111111111…11 因此结果就是-1

# 负数高位会无限补1 -1 存储为：11111111111…11
# 正数高位会无限补0 1  存储为：00000000000…01
# 因此算进位的时候 进位是10=2
# 然后算原位 原位是11111111111…10 因此结果就是-2
# -2 存储为：11111111111…10  2存储为：00000000000…10
# 进位又是 00000000000…10 也就是4 原位算出来是-8
# 到最后 进位终于在前32位都是0了 这个时候会退出循环 然后因为b>mask 这个时候原位也已经出现了前32位都是0的情况，最后舍去前面的位 会输出0
class Solution:
    def getSum(self,a:int,b:int)->int:
        mask = 0xFFFFFFFF
        # 仍然存在进位 或加数不为0
        while b & mask!=0:
            # 算进位
            carry = (a&b)<<1
            print('进位：', bin(carry))
            #算原位
            a = a^b
            print('原位：',bin(a))
            b = carry
        if b > mask:
            print('yes')
            # 似乎是用来平衡0+0
            print('a&mask=',bin(a & mask))
            return a & mask
        else:
            return a

solve = Solution()
a = 1
b = -1
answer = solve.getSum(a,b)
print(answer)
